---
layout: post
title:  GCD
date:   2015-08-13-20:17:20
categories: jekyll update
---

	GCD 理解
	<http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1>
	<http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-2>


#### 1. 什么是GCD
	
	GCD 是 libdispatch 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点：

	GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。
	GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。
	GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。

#### 2. GCD术语

	Serial vs. Concurrent 串行 vs. 并发
	Synchronous vs. Asynchronous 同步 vs. 异步
	Critical Section 临界区
	Race Condition 竞态条件
	Deadlock 死锁
	Thread Safe 线程安全
	Context Switch 上下文切换
	Concurrency vs Parallelism 并发与并行
	Queues 队列
	Serial Queues 串行队列
	Concurrent Queues 并发队列
	Queue Types 队列类型

#### 3. Queue Types 队列类型

	首先，系统提供给你一个叫做 主队列（main queue） 的特殊队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。这个队列就是用于发生消息给 UIView 或发送通知的。

	系统同时提供给你好几个并发队列。它们叫做 全局调度队列（Global Dispatch Queues） 。目前的四个全局队列有着不同的优先级：background、low、default 以及 high。要知道，Apple 的 API 也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。

	最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有五个队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。

	以上是调度队列的大框架！

	GCD 的“艺术”归结为选择合适的队列来调度函数以提交你的工作。体验这一点的最好方式是走一遍下边的列子，我们沿途会提供一些一般性的建议

#### 4. 处理读者与写者问题

	线程安全实例不是处理单例时的唯一问题。如果单例属性表示一个可变对象，那么你就需要考虑是否那个对象自身线程安全。

	如果问题中的这个对象是一个 Foundation 容器类，那么答案是——“很可能不安全”！Apple 维护一个有用且有些心寒的列表，众多的 Foundation 类都不是线程安全的。 NSMutableArray，已用于你的单例，正在那个列表里休息。

	虽然许多线程可以同时读取 NSMutableArray 的一个实例而不会产生问题，但当一个线程正在读取时让另外一个线程修改数组就是不安全的。你的单例在目前的状况下不能预防这种情况的发生

	- (void)addPhoto:(Photo *)photo
	{
	    if (photo) { // 1
	        dispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 
	            [_photosArray addObject:photo]; // 3
	            dispatch_async(dispatch_get_main_queue(), ^{ // 4
	                [self postContentAddedNotification]; 
	            });
	        });
	    }
	}

	你新写的函数是这样工作的：
	在执行下面所有的工作前检查是否有合法的相片。
	添加写操作到你的自定义队列。当临界区在稍后执行时，这将是你队列中唯一执行的条目。
	这是添加对象到数组的实际代码。由于它是一个障碍 Block ，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行。
	最后你发送一个通知说明完成了添加图片。这个通知将在主线程被发送因为它将会做一些 UI 工作，所以在此为了通知，你异步地调度另一个任务到主线程。

	- (NSArray *)photos
	{
	    __block NSArray *array; // 1
	    dispatch_sync(self.concurrentPhotoQueue, ^{ // 2
	        array = [NSArray arrayWithArray:_photosArray]; // 3
	    });
	    return array;
	}

	这就是你的读函数。按顺序看看编过号的注释，有这些：
	__block 关键字允许对象在 Block 内可变。没有它，array 在 Block 内部就只是只读的，你的代码甚至不能通过编译。
	在 concurrentPhotoQueue 上同步调度来执行读操作。
	将相片数组存储在 array 内并返回它。

	+ (instancetype)sharedManager
	{
	    static PhotoManager *sharedPhotoManager = nil;
	    static dispatch_once_t onceToken;
	    dispatch_once(&onceToken, ^{
	        sharedPhotoManager = [[PhotoManager alloc] init];
	        sharedPhotoManager->_photosArray = [NSMutableArray array];

	        // ADD THIS:
	        sharedPhotoManager->_concurrentPhotoQueue = dispatch_queue_create("com.selander.GooglyPuff.photoQueue",
	                                                    DISPATCH_QUEUE_CONCURRENT); 
	    });

	    return sharedPhotoManager;
	}
	这里使用 dispatch_queue_create 初始化 concurrentPhotoQueue 为一个并发队列。第一个参数是反向DNS样式命名惯例；确保它是描述性的，将有助于调试。第二个参数指定你的队列是串行还是并发

#### 5. dispatch_apply
	
	dispatch_apply acts like a for loop which executes different iterations concurrently. This function is sychronous, so just like a normal for loop, dispatch_apply returns only when all of the work is done.

	


[jekyll]:      http://jekyllrb.com
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-help]: https://github.com/jekyll/jekyll-help
